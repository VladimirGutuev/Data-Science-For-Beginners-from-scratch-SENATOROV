"""This module includes a summary of Chapter 4 of Clean Code (pp.85–95)."""

# #  Выбор понятных имен
# Если вы пишете не «одноразовый» код, который вы не собираетесь сопровождать
# после однократного запуска программы, вам стоит подумать над выбором хороших
# имен в вашей программе. Самые важные критерии:
# - содержательность
# - компактность
# ### Схемы регистра имен
# в идентификаторах Python различается регистр символов и они не могут
# содержать пробельные символы, программисты используют несколько схем в иден
# тификаторах, состоящих из нескольких слов.
# -  Змеиный регистр (snake_case) разделяет слова символом подчеркивания,
# который напоминает ползущую между словами змею. В этом случае все
# буквы записываются в нижнем регистре, а константы часто записываются
# в верхнем змеином регистре (UPPER_SNAKE_CASE).
# - Верблюжий регистр (camelCase) — слова записываются в нижнем регистре,
# но второе и следующие слова начинаются с заглавной. Эта схема в большин
# стве случаев подразумевает, что первое слово начинается с буквы нижнего
# регистра. Буквы верхнего регистра напоминают верблюжьи горбы.
# - Схема Pascal (PascalCase) — названа так, потому что применяется в языке
# программирования Pascal; аналогична схеме верблюжьего регистра, но первое
# слово в ней тоже начинается с заглавной.
#
# **Вы можете использовать любую схему, но в одном проекте — только одну, а не
# обе сразу**
# ###  Соглашения об именах PEP 8
# - Все буквы должны быть буквами ASCII — то есть латинскими буквами
# верхнего и нижнего регистров без диакритических знаков.
# - Имена модулей должны быть короткими и состоять только из букв нижнего
# регистра.
# - Имена классов необходимо записывать в схеме Pascal.
# - Имена констант следует записывать в верхнем змеином регистре.
# - Имена функций, методов и переменных записывают в нижнем змеином
# регистре.
# - Первый аргумент методов всегда должен называться self в нижнем регистре.
# - Первый аргумент методов классов всегда должен называться cls в нижнем
# регистре.
# - Приватные атрибуты классов всегда начинают с символа подчеркивания ( _ )
# - Публичные атрибуты классов никогда не начинают с символа подчеркивания (
# _ ).
# ## Длина имён
# Имена не должны быть слишком короткими или слишком длинными, но так как код
# читают чаще, чем пишут, лучше все-таки задавать более длинные имена
# переменных.
# ### Слишком короткие имена
# Они зачастую кажутся вам понятными, когда вы впервые их записываете, но вы
# можете забыть их точный смысл через несколько дней или недель.
# - Одно- или двухбуквенное имя (например, g), вероятно, обозначает какое-то
# слово, начинающееся с этой буквы, но таких слов очень много. Сокращения и
# одно-двухбуквенные имена легко записать, но они плохо читаются. Это замечание
# относится и к следующему пункту.
# - Сокращенные имена вида mon — могут означать monitor, month, monster и
# множество других слов
# - Имя из одного слова — например, start (начало) — может трактоваться по
# разному: начало чего? При отсутствии уточнения другие люди вас вряд ли
# поймут.
#
# В отдельных случаях короткие имена переменных вполне допустимы. Например,
# имя i часто используется с переменными циклов for, перебирающих диапазоны
# чисел или индексов списка, а j и k (следующие за i в алфавитном порядке)
# используются с вложенными циклами
#
# Еще одно исключение — использование x и y для декартовых координат. В
# большинстве других случаев я не рекомендую применять однобуквенные имена
# переменных.
#
# ### Слишком длинные имена
# Как правило, чем больше область видимости имени, тем более содержательным
# оно должно быть. Короткое имя (например, payment) хорошо подойдет для
# локальной переменной в одной короткой функции. Однако имя может оказаться
# недостаточно содержательным, если использовать его для глобальной переменной
# в 10 000-строчной программе, потому что в такой программе могут
# обрабатываться различные виды платежных данных. В такой ситуации лучше
# использовать более содержательное имя salesClientMonthlyPayment или
# annual_electric_bill_payment. Дополнительные слова в имени уточняют смысл и
# устраняют неоднозначность.
#
# Лучше лишние пояснения, чем их нехватка.
#
# старайтесь использовать короткие фразы, с которыми ваш код
# читается как обычный текст. Например, имя number_of_trials читается лучше,
# чем number_trials
#
# ###  Префиксы в именах
# Префиксы в именах иногда избыточны. Например, если у вас есть класс Cat с
# атрибутом weight, очевидно, что weight (вес) относится к кошке (cat). Таким
# образом, имя catWeight будет слишком подробным и длинным.
#
# Аналогичным образом устаревшей считается венгерская запись — практика
# включения сокращения типа данных в имена. Например, имя strName указывает,
# что переменная содержит строковое значение, а iVacationDays — что переменная
# содержит целое число. Современные языки и IDE могут предоставить
# программисту информацию о типе данных без этих префиксов, поэтому венгерская
# запись считается излишней в наше время.
#
# С другой стороны, префиксы is и has у переменных, содержащих логические
# значения, или функций и методов, возвращающих логические значения, делают
# эти имена более понятными. Например:
# ```python
# if item_under_repair.has_key('tires'):
#     is_vehicle = True
# ```
#
# Также включение единиц измерения в имена может предоставить полезную
# информацию. Переменная weight, в которой хранится значение с плавающей
# точкой, неоднозначна: в чем измеряется вес — в фунтах, килограммах или
# тоннах? Информация об единицах измерения не является типом данных, поэтому
# включение префикса или суффикса kg или lbs нельзя считать венгерской записью.
# Имя переменной вида weight_kg оказывается вполне разумным.
#
# ###  Последовательные числовые суффиксы в именах
# Имена переменных вида payment1, payment2 и payment3 не сообщают читателю
# кода, чем они различаются. Возможно, программисту стоит преобразовать эти
# три переменные в один список или переменную-кортеж с именем payments, в
# которой хранятся три значения
#
# Функции вида makePayment1(amount), makePayment2(amount) и т. д., вероятно,
# стоит преобразовать в одну функцию, которая получает целочисленный аргумент:
# makePayment(1, amount), makePayment(2,amount) и т. д. Если эти функции
# обладают разным поведением, оправдывающим определение отдельных функций,
# смысл чисел должен быть отражен в имени, например: makeLowPriorityPayment
# (amount) и makeHighPriorityPayment(amount) или make1stQuarterPayment(amount)
# и make2ndQuarterPayment(amount).
#
# ## Выбирайте имена, пригодные для поиска
# Во всех программах, кроме самых коротких, вам, вероятно, придется
# воспользоваться редактором или функцией поиска (Ctrl-F) в IDE, чтобы найти
# упоминания переменных и функций. Чтобы имя было найдено немедленно,
# создавайте уникальные имена с более длинными именами переменных, которые
# содержат конкретную информацию.Если вы будете помнить об этом правиле, вам
# будет проще выбирать содержательные имена вместо обобщенных. Имя email
# слишком многозначно, поэтому лучше выбрать более содержательное имя:
# emailAddress, downloadEmailAttachment, emailMessage, replyToAddress и т. д.
# Такое имя не только более точное, но его проще найти в исходном коде.
#
# ##  Избегайте шуток, каламбуров и культурных отсылок
# Лучше всего писать код, понятный тем, для кого английский язык не является
# родным, то есть прямолинейно, традиционно и без юмора. Возможно, мой бывший
# коллега решил, что gooseDownload() —смешная шутка, но ничто не убивает шутку
# быстрее, чем необходимость ее объяснять. Годы спустя, когда мой коллега
# уволился из компании, я переименовал его функцию и присвоил ей имя
# increaseDownloadSpee().
#
# ## Не заменяйте встроенные имена
# Никогда не используйте встроенные имена Python для своих переменных.
# Например, присвоив переменной имя list или set, вы заместите функции Python
# list() и set(), что позднее может привести к появлению ошибок. Функция
# list() создает объекты списков, но ее замена может вызвать ошибку
#
# Чтобы узнать, используется ли имя в Python, введите его в интерактивной
# оболочке или попробуйте импортировать. Если имя не используется, вы получите
# ошибку NameError или ModuleNotFoundError
#
# Другая распространенная проблема — присваивание файлам .py имен, совпадающих
# с именами сторонних модулей. Например, если вы установили сторонний модуль
# Pyperclip, но также создали файл pyperclip.py, команда import pyperclip
# импортирует pyperclip.py вместо модуля Pyperclip. При попытке вызвать
# функцию copy() или paste() модуля Pyperclip вы получите ошибку, в которой
# говорится,  что функции не существует.
#
