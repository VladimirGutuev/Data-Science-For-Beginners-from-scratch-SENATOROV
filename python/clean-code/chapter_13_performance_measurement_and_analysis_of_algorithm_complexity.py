"""This module includes a summary of Chapter 13 of Clean Code (pp.

264–287).
"""

# #  Измерение быстродействия и анализ сложности алгоритмов
# Иногда стоит озадачиться ускорением работы сценария. Но чтобы понять,
# привели ли изменения к повышению быстродействия, необходимо знать, как
# измерить скорость программы. На помощь приходят модули Python timeit и
# cProfile. Они не только изменяют время выполнения кода, но и строят профиль,
# показывающий, какие части кода уже выполняются быстро, а какие можно
# улучшить вы также узнаете, как оценивать теоретический рост времени
# выполнения с увеличением объема данных. В компьютерной науке эта зависимость
# называется нотацией «O-большое».
# ## Модуль timeit
# «Преждевременная оптимизация — корень всех зол» — популярное изречение в
# области разработки. Преждевременная оптимизация (то есть оптимизация,
# выполняемая до того, как вы поймете, что же нужно оптимизировать) часто
# проявляется, когда программисты пытаются использовать хитроумные трюки для
# экономии памяти или написания более быстрого кода.
#
# Первая строка, передаваемая в функцию timeit принимает строчки кода в
# формате string, разделённые ; знаком. Функция timeit.timeit() также может
# получить второй строкой аргумент с подготовительным кодом, который
# выполняется только один раз перед выполнением кода первой строки. Также
# можно изменить количество испытаний по умолчанию, передав целое число в
# ключевом аргументе number.

# +
import cProfile
import timeit

timeit.timeit("random.randint(1, 100)", "import random", number=10000000)


# -

# ## Профилировщик cProfile
# Модуль cProfile более эффективен для анализа целых функций или программ.
# Процесс профилирования систематически анализирует скорость вашей программы,
# затраты памяти и другие аспекты. Модуль cProfile — профилировщик Python, то
# есть программа, измеряющая время выполнения программы, а также строящая
# профиль времени выполнения отдельных вызовов функций программы. Эта
# информация предоставляет намного более детализированные результаты
# хронометража вашего кода.
#
# Чтобы воспользоваться профилировщиком cProfile, передайте код, для которого
# хотите провести измерения, при вызове cProfile.run()


# +
def add_up_numbers() -> None:
    """Test function."""
    total = 0
    for i in range(1, 1000001):
        total += i


cProfile.run("add_up_numbers()")
# -

# Существует закон Амдала - формула, которая вычисляет, насколько ускорится
# выполнение программы при улучшении одного из ее фрагментов. Согласно этой
# формуле ускорение всей операции равно 1 / ((1 — p) + (p / s)), где s —
# ускорение компонента, а p — доля этого компонента в общем времени выполнения
# программы. Просто запомните, что удвоение скорости самых медленных или
# длинных частей вашего кода более продуктивно, чем удвоение скорости уже
# быстрых или коротких частей. Этот вывод подтверждается здравым смыслом:
# 10-процентная скидка на изделие дорогого модного дома лучше 10-процентной
# скидки на пару дешевой обуви.

# ## Анализ алгоритмов с использованием нотации "О-большое"
# Нотация "О-большое" — метод анализа алгоритмов, описывающий масштабирование
# времени выполнения кода. Код классифицируется по нескольким порядкам
# сложности, каждый из которых в общем виде показывает, насколько увеличится
# время выполнения кода при возрастании объема выполняемой работы. Разработчик
# Python Нед Бэтчелдер описывает нотацию "О-большое" как метод анализа,
# который определяет «насколько замедлится код с ростом объема данных»
#
# Нотация "O-большое" описывает эту картину. Алгоритм может выполняться на
# быстром или медленном компьютере, но нотация "O-большое" все равно может
# использоваться для описания быстродействия алгоритма в целом независимо от
# того, на каком оборудовании этот алгоритм выполняется.
#
# ## Порядки нотации "О-большое"
# Нотация "О-большое" обычно определяет несколько порядков сложности. Ниже эти
# порядки перечислены по возрастанию (сначала указаны низкие порядки, при
# которых код с ростом объема данных замедляется в наименьшей степени, а в
# конце — высокие порядки с наибольшим замедлением)
#
#  1. O(1), постоянное время (самый низкий порядок).
#  2. O(log n), логарифмическое время.
#  3. O(n), линейное время.
#  4. O(n log n), время N-Log-N.
#  5. O(n2), полиномиальное время.
#  6. O(2n), экспоненциальное время.
#  7. O(n!), факториальное время (наивысший порядок).
#
# - O(1) и O(log n) - быстрые алгоритмы.
# - O(n) и O(n log n) - неплохие алгоритмы.
# - O(n^2), O(2^n) и O(n!) - медленные алгоритмы
#
# ## "О-большое" как оценка худшего сценария
# "О-большое" оценивает худший сценарий для любой задачи.
#
# Некоторые программисты также используют нотацию "Омега-большое", описывающую
# лучший сценарий для алгоритма. Например, алгоритм Ω(n) в
# лучшем случае работает с линейной эффективностью. В худшем случае он может
# работать медленнее.
#
# Нотация "Тэта-большое" описывает алгоритмы с одинаковыми порядками в лучшем
# и худшем случае. Например, Θ(n) описывает алгоритм с
# линейной эффективностью в лучшем и худшем случае — то есть алгоритм O(n) и
# Ω(n).
#
# ##  "О-большое" не имеет значения при малых n… а значения n обычно малы
# Теперь у вас может возникнуть искушение анализировать каждый написанный вами
# фрагмент кода. Прежде чем с азартом лупить по каждому гвоздю, попавшему в
# поле зрения, следует учесть, что нотация "О-большое" полезна прежде всего
# при большом объеме обрабатываемых данных. В реальных ситуациях объем данных
# обычно невелик.
